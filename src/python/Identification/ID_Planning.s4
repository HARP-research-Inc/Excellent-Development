<task "tree_identification">
    -input:
        <json "chunked_sheets">
    -output:
        <json "template_sheet">
        <json "sheet_instances">
        
    <task "cell_labeling">
        -input:
            <json "chunked_sheets">
        -output:
            <json "annotated_cells">

    <task "solid_block_identification">
        -input:
            <json "annotated_cells">
        -output:
            <json "blocks_output">

    <task "solid_table_identification">
        -input:
            <json "blocks_output">
        -output:
            <json "solid_table_output">

    <task "solid_table_ID2">
        ~turns solid tables into solid tables of solid tables up one level of abstraction in order to make up for mislabeling~
        -input:
            <json "solid_table_output">
        -output:
            <json "layered_solid_table_output">

    <task "light_block_identification">
        ~take blocks that are unattached to tables, check for tables next to or one off from tables, following same order of priority of ST_ID connections~
        ~creates based on AB, BB, CB, DB patterns~
        -input:
            <json "layered_solid_table_output">
        -output:
            <json "layered_light_block_output">

    <task "pattern_table_splitting">
        ~goes through tables and checks for patterns in non-prime sized tables: Non-prime x length tables excluding labels for splitting in x, non-prime y length tables excluding labels for splitting in y)~
        -input:
            <json "layered_light_block_output">
        -output:
            <json "pattern_split_LB">

    <task "light_table_identification">
        ~recursively turns solid and light tables into tables of tables into a tree structure, similar in principle to LB_ID~
        -input:
            <json "pattern_split_LB">
        -output:
            <json "table_tree">

    <task "template_extraction">
        ~turns the organized sheet trees into templates, with every potential DOF listed~
        -input:
            <json "table_tree">
        -output:
            <json "template_tree">

    <task "multi_document_dof_comparison">
        ~using Generalized Trees or Least Common Ancestor (LCA) to compare DOFs in template trees to find the most general tree~
        -input:
            <json "template_tree">
        -output:
            <json "generalized_template_tree">
                <table>
                    -properties:
                        <coordinates "expected_start">
                            ~most left, top starting coordinates of any children relative to parent~
                        <dict "coordinate_hash">
                            ~a hashmap with coordinates as keys 
                        <subtables>
                            -properties:
                                <expected_start>
                                    ~most left, top starting coordinates of subtables realtive to parent table~
                            -assembly:
                                <table>
                        <data_block>
                            -properties:
                                <expected_start>
                                    ~start coord realtive to parent table~
                        <light_labels>
                            ~a block of light labels which refer to the entire table, always farther than SB Labels~
                            -properties:
                                <expected_start>
                                    ~start coord realtive to parent table~
                            -assembly:
                                <light_label_block>
                                    -properties:
                                        <expected_start>
                                            ~first cell to look for label block in, relative to table~
                                        <label_values>
                                            ~ordered list of value expected to be found in the label block~
                        <labels>
                            ~dictionary of label blocks~
                            -assembly:
                                <label_block>
                                    -name:
                                        <position_name>[value]
                                    -properties:
                                        <expected_start>
                                            ~first cell to look for label blcok in, relative to table~
                                        <label_values>
                                            ~ordered list of values expected to be found in the label block~
                        <table_dict>
                            ~function which maps light labels to the entire table and the data/labels to a dictionary with labels as keys, with subdictionaries added for amount of label blocks. if in-line label blocks are identical, ignore secondary one.~
                            ~subtables are listed left to right, top to bottom by expected_start~
                            